tenho outro tipo de usuario "medico" eu quero ao fazer login cair no medico ou paciente dependendo de quem esta a logar, porem eu criei home separado para cada um
import React, { useState, useRef } from 'react'; // Adicionado useRef
import {
  View,
  Text,
  TextInput,
  TouchableOpacity,
  SafeAreaView,
  ScrollView,
  KeyboardAvoidingView,
  Platform,
  StatusBar,
  Alert,
  ActivityIndicator,
} from 'react-native';
import IconFA5 from 'react-native-vector-icons/FontAwesome5';

// Importa o hook useAuth do contexto local (VERIFIQUE O CAMINHO!)
import { useAuth } from './context/AuthContext';

// Importa funções e instância do Firebase Auth (VERIFIQUE O CAMINHO!)
import { signInWithEmailAndPassword } from 'firebase/auth';
import { auth } from './firebaseconfig';

// Importa os estilos e o tema do arquivo separado
import styles, { theme } from './style/LoginScreen.styles.js';

// --- COMPONENTE HeaderIcon (movido para cá) ---
// Recebe estilos como prop para desacoplar
const HeaderIcon = ({ iconName, size = 60, color = theme.colors.white, backgroundColor = theme.colors.primary }) => (
  // Usa o estilo importado
  <View style={[styles.headerIconContainer, { width: size, height: size, borderRadius: size / 2, backgroundColor }]}>
    <IconFA5 name={iconName} size={size * 0.55} color={color} />
  </View>
);

// --- COMPONENTE PRINCIPAL ---
function LoginScreen({ navigation }) {
  // --- ESTADOS ---
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [focusedInput, setFocusedInput] = useState(null);
  const [isLoading, setIsLoading] = useState(false);

  // --- REFERÊNCIAS ---
  const passwordInputRef = useRef(null); // Referência para o input de senha

  // --- CONTEXTO ---
  const { login: loginContext } = useAuth();

  // --- HANDLERS ---
  const handleLogin = async () => {
    if (!email.trim() || !password) {
      Alert.alert('Campos Vazios', 'Por favor, preencha o e-mail e a senha.');
      return;
    }
    setIsLoading(true);
    try {
      const userCredential = await signInWithEmailAndPassword(auth, email.trim(), password);
      const firebaseUser = userCredential.user;
      console.log('Login com Firebase bem-sucedido:', firebaseUser.uid);

      const userDataForContext = {
        id: firebaseUser.uid,
        name: firebaseUser.displayName || email.split('@')[0].replace(/[^a-zA-Z0-9]/g, ' ').replace(/\b\w/g, l => l.toUpperCase()) || 'Usuário(a)',
        email: firebaseUser.email,
      };

      await loginContext(userDataForContext);
      // Navegação implícita pelo AuthProvider

    } catch (error) {
      console.error("Erro no login com Firebase:", error.code, error.message);
      let friendlyMessage = 'Usuario ou senha incorreta. Tente novamente.';
      switch (error.code) {
        case 'auth/invalid-email': friendlyMessage = 'O endereço de e-mail não é válido.'; break;
        case 'auth/user-disabled': friendlyMessage = 'Este usuário foi desabilitado.'; break;
        case 'auth/user-not-found': friendlyMessage = 'Nenhum usuário encontrado com este e-mail.'; break;
        case 'auth/wrong-password': friendlyMessage = 'Senha incorreta. Por favor, verifique sua senha.'; break;
        case 'auth/too-many-requests': friendlyMessage = 'Acesso bloqueado devido a muitas tentativas. Tente mais tarde.'; break;
      }
      Alert.alert('Falha no Login', friendlyMessage);
    } finally {
      setIsLoading(false);
    }
  };

  const handleForgotPassword = () => {
    console.log('Clicou em "Esqueci a senha"');
    Alert.alert('Indisponível', 'A recuperação de senha ainda não foi implementada.');
    // navigation.navigate('ForgotPassword'); // Se existir a tela
  };

  const goToRegister = () => {
    if (navigation) {
      navigation.navigate('Register'); // Nome da rota de cadastro
    }
  };

  const handleFocus = (inputName) => setFocusedInput(inputName);
  const handleBlur = () => setFocusedInput(null);

  // --- RENDERIZAÇÃO ---
  return (
    <SafeAreaView style={styles.safeArea}>
      <StatusBar barStyle="dark-content" backgroundColor={theme.colors.background} />
      <KeyboardAvoidingView
        behavior={Platform.OS === "ios" ? "padding" : "height"}
        style={styles.keyboardAvoiding}
      >
        <ScrollView
            contentContainerStyle={styles.scrollViewContent}
            keyboardShouldPersistTaps="handled" // Fecha teclado ao tocar fora
        >
          <View style={styles.container}>
            {/* Ícone (agora definido neste arquivo) */}
            <HeaderIcon iconName="briefcase-medical" />

            <Text style={styles.title}>Login</Text>

            <View style={styles.form}>
              <TextInput
                style={[
                  styles.input,
                  focusedInput === 'email' && styles.inputFocused,
                  isLoading && styles.inputDisabled // Aplica estilo desabilitado
                ]}
                placeholder="E-mail"
                placeholderTextColor={theme.colors.placeholder}
                value={email}
                onChangeText={setEmail}
                keyboardType="email-address"
                textContentType="emailAddress"
                autoCapitalize="none"
                autoComplete="email"
                autoCorrect={false}
                onFocus={() => handleFocus('email')}
                onBlur={handleBlur}
                returnKeyType="next"
                onSubmitEditing={() => passwordInputRef.current?.focus()} // Foca no próximo input
                editable={!isLoading} // Desabilita quando carregando
              />

              <TextInput
                ref={passwordInputRef} // Aplica a referência
                style={[
                  styles.input,
                  focusedInput === 'password' && styles.inputFocused,
                  isLoading && styles.inputDisabled // Aplica estilo desabilitado
                ]}
                placeholder="Senha"
                placeholderTextColor={theme.colors.placeholder}
                value={password}
                onChangeText={setPassword}
                secureTextEntry={true}
                textContentType="password"
                autoComplete="password"
                onFocus={() => handleFocus('password')}
                onBlur={handleBlur}
                returnKeyType="done" // Botão "Concluído" ou similar no teclado
                onSubmitEditing={handleLogin} // Tenta logar ao pressionar "done"
                editable={!isLoading} // Desabilita quando carregando
              />

              <TouchableOpacity
                style={styles.forgotPasswordContainer}
                onPress={handleForgotPassword}
                disabled={isLoading} // Desabilita quando carregando
              >
                <Text style={[
                    styles.forgotPasswordText,
                    isLoading && styles.linkDisabled // Aplica estilo desabilitado
                ]}>
                    Esqueci a senha?
                </Text>
              </TouchableOpacity>

              <TouchableOpacity
                style={[styles.button, isLoading && styles.buttonDisabled]} // Estilo desabilitado
                onPress={handleLogin}
                disabled={isLoading} // Desabilita toque
              >
                {isLoading ? (
                  <ActivityIndicator size="small" color={theme.colors.white} />
                ) : (
                  <Text style={styles.buttonText}>Entrar</Text>
                )}
              </TouchableOpacity>

              <TouchableOpacity
                 style={styles.registerLinkContainer}
                 onPress={goToRegister}
                 disabled={isLoading} // Desabilita quando carregando
                >
                 <Text style={[
                    styles.registerLinkText,
                    isLoading && styles.linkDisabled // Aplica estilo desabilitado
                ]}>
                    Não tem uma conta? Cadastre-se
                 </Text>
               </TouchableOpacity>
            </View>
          </View>
        </ScrollView>
      </KeyboardAvoidingView>
    </SafeAreaView>
  );
}

// --- EXPORTAÇÃO ---
export default LoginScreen;

import React from 'react';
import { createStackNavigator } from '@react-navigation/stack';
import { NavigationContainer } from '@react-navigation/native';

// Importe o hook de autenticação (relativo a navegation/)
import { useAuth } from '../context/AuthContext';

// Importe suas telas (ajuste '../screens/' se estiverem em outro lugar)
import WelcomeScreen from '../welcomeScreen';   // Assumindo screens/WelcomeScreen.js
import LoginScreen from '../login';       // Assumindo screens/LoginScreen.js
import RegisterScreen from '../cadastro';  // Assumindo screens/RegisterScreen.js

// Importe o componente que contém as Tabs (caminho original)
import AppTabs from '../pacientes/(tabs)/tabNavegation'; // Caminho do seu código



const Stack = createStackNavigator();

const StackNavigator = () => {
  // Use o hook para obter o estado de login e carregamento
  const { isLoggedIn, isLoading } = useAuth();

  // Se ainda estiver carregando, retorne null ou um splash/loading
   if (isLoading) {
     return null; // Ou <SplashScreen />
   }

  return (
    // O NavigationContainer fica aqui
    <NavigationContainer>
      {/* Usa os nomes de rota do seu código original */}
      <Stack.Navigator initialRouteName={isLoggedIn ? "Home" : "Welcome"} screenOptions={{ headerShown: false }}>
        {isLoggedIn ? (
          // --- Tela Logada ---
          // A rota "Home" agora aponta para o componente das suas abas
          <Stack.Screen
            name="Home" // Mantém o nome da rota principal
            component={AppTabs} // Usa o componente de abas importado
          />
          // Adicione outras telas *fora* das abas que precisam de login aqui, se houver

        ) : (
          // --- Telas Não Logadas ---
          // Mantém as telas de autenticação
          <>
            <Stack.Screen name="Welcome" component={WelcomeScreen} />
            <Stack.Screen name="Login" component={LoginScreen} />
            <Stack.Screen name="Register" component={RegisterScreen} />
            
            {/* <Stack.Screen name="ForgotPassword" component={ForgotPasswordScreen} /> */}
          </>
        )}
      </Stack.Navigator>
    </NavigationContainer>
  );
};

export default StackNavigator;

// src/context/AuthContext.js
import React, { createContext, useState, useContext, useEffect } from 'react';
import AsyncStorage from '@react-native-async-storage/async-storage'; // Para persistência (opcional, mas recomendado)

// 1. Criar o Contexto
const AuthContext = createContext(null);

// 2. Criar o Provedor
export const AuthProvider = ({ children }) => {
  const [user, setUser] = useState(null); // Estado para guardar os dados do usuário
  const [isLoading, setIsLoading] = useState(true); // Estado para verificar se está carregando o usuário do storage

  // Efeito para tentar carregar o usuário do AsyncStorage ao iniciar o app
  useEffect(() => {
    const loadUserFromStorage = async () => {
      try {
        const storedUser = await AsyncStorage.getItem('@auth_user');
        if (storedUser) {
          setUser(JSON.parse(storedUser));
        }
      } catch (e) {
        console.error("AuthProvider: Erro ao carregar usuário do storage", e);
        // Tratar erro, talvez limpar storage
      } finally {
        setIsLoading(false); // Finaliza o carregamento inicial
      }
    };

    loadUserFromStorage();
  }, []);

  // Função de Login
  const login = async (userData) => {
    try {
      console.log("AuthProvider: Logando usuário:", userData);
      setUser(userData); // Define o usuário no estado
      // Salva o usuário no AsyncStorage para persistência
      await AsyncStorage.setItem('@auth_user', JSON.stringify(userData));
    } catch (e) {
      console.error("AuthProvider: Erro ao salvar usuário no storage", e);
    }
  };

  // Função de Logout
  const logout = async () => {
    try {
      console.log("AuthProvider: Deslogando usuário");
      setUser(null); // Limpa o usuário do estado
      // Remove o usuário do AsyncStorage
      await AsyncStorage.removeItem('@auth_user');
    } catch (e) {
      console.error("AuthProvider: Erro ao remover usuário do storage", e);
    }
  };

  // Valor fornecido pelo contexto
  const value = {
    user,
    isLoggedIn: !!user, // True se user não for null
    isLoading,         // Para saber se o estado inicial já foi carregado
    login,
    logout,
  };

  // Não renderiza nada até que o estado inicial seja carregado (evita piscar a tela de login)
  if (isLoading) {
     // Pode retornar um componente de Loading aqui se preferir
     return null;
   }

  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
};

// 3. Hook customizado para usar o contexto
export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth deve ser usado dentro de um AuthProvider');
  }
  return context;
};